# results

# Usage
To run knapsack or coloring algorithms on all inputs with a time limit per problem, simply change to the respective    directory, and run `python3 coloring.py <timelimit>` or `python3 knapsack.py <timelimit>`. The timelimit parameter is  in seconds.

# Knapsack
The Knapsack solution provided aims to optimize an array of binary variables which represent whether each object has   been selected. This optimization is subject to the constraint that the total cost of all selected items must be less   than or equal to the cost bound. CPLEX is able to solve all given instances of this in well under the time limit. The  solutions found are all at least as good as those found by greedy and exhaustive algorithms.

# Coloring

The ILP solution for graph coloring attempts to solve the graph coloring problem using ILP run with AMPL/ CPLEX. For   this problem, we were given a starter model file and several data files for  different instances. To finish the        implementation of the model file, we needed to figure out the objective function as well as two constraints. Since we  want to minimize the number of coloring conflicts in our graph, our objective function reflected this; we minimized    the sum of all elements stored in a ‘i x j’ matrix representing conflicts between nodes i and nodes j. For the first   constraint, we wanted to limit each node to having exactly one color; this was accomplished by ensuring the sum of a   row in a ‘i x c’ matrix representing the colors of node i was equal to 1. The second constraint proved to be more      difficult but we essentially had to create a constraint that would detect conflicts. To do this we created a           constraint that checked if an edge between a pair of nodes existed and whether or not those two nodes had the same     color, if so then it should also appear in a “conflict” matrix representing conflicts between nodes i and nodes j.     With this, we created a constraint ,”edge[i,j] * (color[i,c] + color[j,c] - 1) - conflict[i,j] <= 0;”, that would      detect conflicts.  Compared to the exhaustive algorithm, the ILP solution performed much better and faster for all     instances. Compared to the greedy algorithm, ILP performed similarly but was able to find optimal solutions with less  conflicts for some instances. However the greedy algorithm performed much quicker for larger instances whereas ILP had to be limited to 10 minutes.
